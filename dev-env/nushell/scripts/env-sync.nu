#!/usr/bin/env nu

# Sync environment variables across environments
# Usage: nu scripts/env-sync.nu [--source file] [--target environment] [--merge]

use ../common.nu *

def main [
    --source: string = ".env"
    --target: string = "all"
    --merge = false
    --backup = true
] {
    log info "Syncing environment variables..."
    
    if not ($source | path exists) {
        log error $"Source file not found: ($source)"
        exit 1
    }
    
    let env_vars = parse-env-file $source
    log info $"Loaded ($env_vars | length) environment variables from ($source)"
    
    if $target == "all" {
        sync-to-all-environments $env_vars $merge $backup
    } else {
        sync-to-environment $target $env_vars $merge $backup
    }
}

def parse-env-file [file_path: string] {
    let content = open $file_path
    let lines = $content | lines
    
    $lines
    | where not ($it | str starts-with "#")
    | where not ($it | str trim | is-empty)
    | where ($it | str contains "=")
    | each { |line|
        let parts = $line | split row "=" --max 2
        if ($parts | length) >= 2 {
            {
                key: ($parts.0 | str replace "export " "" | str trim)
                value: ($parts.1 | str trim)
                line: $line
            }
        }
    }
    | where ($it | is-not-empty)
}

def sync-to-all-environments [env_vars: list, merge: bool, backup: bool] {
    let environments = ["python-env", "typescript-env", "rust-env", "go-env"]
    
    for env in $environments {
        if ($env | path exists) {
            log info $"Syncing to ($env)..."
            sync-env-to-directory $env $env_vars $merge $backup
        } else {
            log warn $"Environment not found: ($env)"
        }
    }
    
    log success "Environment sync completed!"
}

def sync-to-environment [target: string, env_vars: list, merge: bool, backup: bool] {
    let target_dir = $"($target)-env"
    
    if not ($target_dir | path exists) {
        log error $"Environment not found: ($target_dir)"
        exit 1
    }
    
    log info $"Syncing to ($target_dir)..."
    sync-env-to-directory $target_dir $env_vars $merge $backup
}

def sync-env-to-directory [dir: string, env_vars: list, merge: bool, backup: bool] {
    let env_file = $"($dir)/.env"
    
    # Create backup if requested
    if $backup and ($env_file | path exists) {
        let backup_file = $"($env_file).backup.(date now | format date '%Y%m%d_%H%M%S')"
        cp $env_file $backup_file
        log info $"  Created backup: ($backup_file)"
    }
    
    # Handle merging vs overwriting
    let final_vars = if $merge and ($env_file | path exists) {
        merge-env-vars $env_file $env_vars
    } else {
        $env_vars
    }
    
    # Write environment file
    write-env-file $env_file $final_vars
    
    log success $"  ✅ Synced ($final_vars | length) variables to ($env_file)"
}

def merge-env-vars [existing_file: string, new_vars: list] {
    let existing_vars = parse-env-file $existing_file
    let existing_keys = $existing_vars | get key
    
    # Keep existing vars that aren't being overridden
    let preserved_vars = $existing_vars | where not ($it.key in ($new_vars | get key))
    
    # Combine with new vars
    $preserved_vars | append $new_vars
}

def write-env-file [file_path: string, env_vars: list] {
    let header = $"# Environment Variables
# Generated by nu scripts/env-sync.nu on (date now | format date '%Y-%m-%d %H:%M:%S')
# 
"
    
    let content = $env_vars 
    | each { |var| $"export ($var.key)=($var.value)" }
    | str join "\n"
    
    $"($header)($content)\n" | save $file_path --force
}

# Specific sync operations
def "main sync-secrets" [
    --target: string = "all"
] {
    log info "Syncing secrets using Teller..."
    
    if not (cmd exists "teller") {
        log error "Teller not found. Install with: brew install teller-ops/teller/teller"
        exit 1
    }
    
    if not (".teller.yml" | path exists) {
        log error ".teller.yml configuration not found"
        exit 1
    }
    
    # Export secrets to temporary file
    let temp_env = "tmp/secrets.env"
    mkdir tmp
    
    try {
        teller export env > $temp_env
        log success "Secrets exported to temporary file"
        
        # Sync secrets to environments
        main --source $temp_env --target $target --merge
        
        # Clean up
        rm $temp_env
        log info "Temporary secrets file cleaned up"
        
    } catch { |e|
        log error $"Failed to sync secrets: ($e.msg)"
        exit 1
    }
}

def "main sync-from-template" [
    template_file: string
    --target: string = "all"
] {
    if not ($template_file | path exists) {
        log error $"Template file not found: ($template_file)"
        exit 1
    }
    
    log info $"Syncing from template: ($template_file)"
    
    let template_vars = parse-env-file $template_file
    let filtered_vars = $template_vars 
    | where not ($it.value | str starts-with "#")
    | where not ($it.value | str contains "your_")
    | where not ($it.value | str contains "example")
    
    if ($filtered_vars | length) == 0 {
        log warn "No usable variables found in template (all are examples/comments)"
        return
    }
    
    log info $"Found ($filtered_vars | length) usable variables in template"
    
    if $target == "all" {
        sync-to-all-environments $filtered_vars true true
    } else {
        sync-to-environment $target $filtered_vars true true
    }
}

def "main validate-env" [
    --environment: string = "all"
] {
    log info "Validating environment variable consistency..."
    
    let environments = if $environment == "all" {
        ["python-env", "typescript-env", "rust-env", "go-env", "nushell-env"]
    } else {
        [$"($environment)-env"]
    }
    
    mut all_vars = {}
    
    # Collect all environment variables
    for env in $environments {
        let env_file = $"($env)/.env"
        if ($env_file | path exists) {
            let env_vars = parse-env-file $env_file
            $all_vars = $all_vars | upsert $env $env_vars
        } else {
            log warn $"No .env file in ($env)"
        }
    }
    
    # Find inconsistencies
    let all_keys = $all_vars 
    | values 
    | flatten 
    | get key 
    | uniq
    
    for key in $all_keys {
        let values_by_env = $all_vars 
        | transpose env vars
        | each { |item|
            let var = $item.vars | where key == $key | first
            if ($var | is-not-empty) {
                {env: $item.env, value: $var.value}
            }
        }
        | where ($it | is-not-empty)
        
        let unique_values = $values_by_env | get value | uniq
        
        if ($unique_values | length) > 1 {
            log warn $"Inconsistent values for ($key):"
            for env_val in $values_by_env {
                log warn $"  ($env_val.env): ($env_val.value)"
            }
        } else {
            log success $"✅ ($key) is consistent across environments"
        }
    }
}

def "main clean-env" [
    --environment: string = "all"
    --dry-run = false
] {
    log info "Cleaning up environment files..."
    
    let environments = if $environment == "all" {
        ["python-env", "typescript-env", "rust-env", "go-env", "nushell-env"]
    } else {
        [$"($environment)-env"]
    }
    
    for env in $environments {
        let env_file = $"($env)/.env"
        if ($env_file | path exists) {
            let env_vars = parse-env-file $env_file
            let clean_vars = $env_vars 
            | where not ($it.value | str trim | is-empty)
            | where not ($it.value | str contains "# REMOVE")
            | where not ($it.key | str contains "TEMP_")
            
            let removed_count = ($env_vars | length) - ($clean_vars | length)
            
            if $removed_count > 0 {
                if $dry_run {
                    log info $"Would remove ($removed_count) variables from ($env_file)"
                } else {
                    write-env-file $env_file $clean_vars
                    log success $"✅ Cleaned ($removed_count) variables from ($env_file)"
                }
            } else {
                log info $"No cleanup needed for ($env_file)"
            }
        }
    }
}